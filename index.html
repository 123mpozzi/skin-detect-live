<!doctype html>
<html lang="en">
<head>

 <!-- TODO: stable-pyodide-once-OpenCV-is-added -->
 

  <!-- Basic Page Needs
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta charset="utf-8">
  <title>Adaptive rule-based Skin Detector | 123mpozzi</title>
  <meta name="description" content="Detect human skin pixels directly from your browser using adaptive thresholding!">
  <meta name="author" content="123mpozzi">

  <!-- Mobile Specific Metas
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- FONT
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link href="https://fonts.googleapis.com/css?family=Raleway:400,300,600" rel="stylesheet" type="text/css">

  <!-- CSS
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="stylesheet" href="css/normalize.css">
  <link rel="stylesheet" href="css/skeleton.css">
  <link rel="stylesheet" href="css/styles.css">

  <!-- Favicon
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="icon" type="image/png" href="images/favicon.png">

  <!-- JS
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <script src="https://cdn.jsdelivr.net/pyodide/dev/full/pyodide.js"></script>
  <script src="main.js"></script>
</head>

<body>

  <!-- Primary Page Layout
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <div class="container">
    <div class="row">
      <a href="https://github.com/123mpozzi/skin-detect-live" class="github-corner" aria-label="View source on GitHub" style="position: fixed; top: 0; right: 0; z-index: 5;" target="_blank" ><svg width="7rem" height="7rem" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
      <div id="navbar" class="row u-full-width">
        <a href="probability.html">Try Statistical</a>
        <a href="unet.html">Try U-Net</a>
      </div>
      <div id="page">
        <h4 id="heading" style="text-align: center;">Adaptive rule based skin detector</h4>
        <div class="main-wrapper">
          <div class="padder"></div>
          <div>
          <p>
            Apart from requiring <i>colored images</i>, this live demo has some <b>additional limitations</b>:
          </p>
          <ul>
            <li>Images must be hosted on the same website (use Wikipedia, Imgur, Flickr)</li>
            <li>Slower: do not use big images</li>
            <li>Webpage may freeze, do not refresh</li>
          </ul>
          <p>
            Also take note that <i>filtered images</i> are bad because the colors are altered
          </p>
          </div>
          <p id="info">STATUS - Ready, Waiting input</p>
          <div class="u-full-width search-form" >
            <div id="url-container" class="six columns" >
              <input id="name" name="name" class="two-thirds column" type="search" 
              placeholder="Paste an image URL">
              <span style="width: 40px;"></span>
              <span id="randomness" class="one columns"
              onclick="insertRandom()"></span>
            </div>
            <button class="one-half column button-primary"
            style="margin-left: 0; margin-bottom: 30px;"
            onclick="skinDetect()">Detect Skin</button>
          </div>
          <div id="slider-container" class="u-full-width">
            <img id="imgbox-ori" alt="Waiting for detection..." title="Original image" />
            <img id="imgbox" alt="Waiting for detection..." title="Detected skin pixels" />
            <input type="range" min="0" max="100" value="50" id="slider" oninput="slide()">
          </div>
        </div>
      </div>
      <div class="row u-full-width">
        <hr />
        <p style="text-align: center;">
          Styled with Skeleton - Powered by Pyodide
        </p>
      </div>
    </div>
  </div>

  <!-- Pyodide
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <script type="text/javascript">
    function isValidHttpUrl(string) {
      let url;
      
      try {
        url = new URL(string);
      } catch (_) {
        return false;  
      }

      return url.protocol === "http:" || url.protocol === "https:";
    }

    // Init Pyodide
    async function initPyodide() {
      document.getElementById('info').innerText = 'STATUS - Loading python...'
      let pyodide = await loadPyodide();
      await pyodide.loadPackage("opencv-python");
      document.getElementById('info').innerText = 'STATUS - Ready, Waiting input'
      return pyodide;
    }
    let pyodideReadyPromise = initPyodide();

    async function skinDetect(){
      let pyodide = await pyodideReadyPromise;
      let samples = getSamples();
      pyodide.registerJsModule("livedemo", {samples});
      document.getElementById('info').innerText = 'STATUS - Checking URL...'
      if (!isValidHttpUrl(document.getElementById("name").value)) {
        document.getElementById('info').innerText = 'STATUS - Invalid URL. Does it start with https:// ?'
        return;
      }
      document.getElementById('info').innerText = 'STATUS - Running script...'
      await pyodide.runPythonAsync(`
          import cv2
          import numpy as np
          from math import ceil
          import os
          import random
          import js
          import base64
          from pyodide.http import pyfetch
          from livedemo import samples

          print(f'Running OpenCV version: {cv2.__version__}')
          info_elem = js.document.getElementById("info")
          img_url = js.document.getElementById("name").value

          def info(string: str):
            print(string)
            info_elem.innerText = "STATUS - " + string

          
          bins = 256
          tolCr = 1
          tolCb = 1
          hist_size = (bins, bins)
          ranges1 = (0, 255)
          ranges2 = (0, 255)
          ranges = (ranges1, ranges2)


          #  sort of the histogram
          def sortHist(iBins: list, values: list, num: int):
            tmpN = num

            while tmpN >= 0:
              ultimo = -1
              for i in range(tmpN):
                if iBins[i] > iBins[i + 1]:
                  tmp = iBins[i]
                  iBins[i] = int(iBins[i + 1])
                  iBins[i + 1] = int(tmp)
                  ultimo = i
                  tmp = values[i]
                  values[i] = values[i + 1]
                  values[i + 1] = tmp
              tmpN = ultimo
            return iBins

          #  Computation of Min and Max of the histogram (5th and 95th percentile)
          def calcMinMaxHist(yValues: int, iBins: list, vect: list) -> None:
            flag = 0
            maxVal = 0
            percentage = 0
            app = [0] * bins #  TODO: rewrite these assignments in a more pythonic way
            for i in range(yValues[0]):
              app[i] = 0
            for i in range(1, yValues[0]):
              maxVal = maxVal + yValues[i]
            i = 1
            if int(maxVal != 0):
              while flag != 1:
                percentage = percentage + int(yValues[i])

                if ceil((percentage / maxVal) * 100) >= 5:
                  flag = 1
                i = i+1
              vect[0] = i - 1
              i = 1
              flag = 0
              percentage = 0
              while flag != 1:
                percentage = percentage + int(yValues[i])
                if ceil((percentage / maxVal) * 100) >= 95:
                  flag = 1
                i = i+1
              vect[1] = i - 1

              k = 0
              for i in range(vect[0], vect[1] +1):
                if iBins[i] != 0:
                  app[k] = iBins[i]
                  k = k+1
              app = sortHist(app, iBins, k - 1)
              vect[0] = 255
              vect[1] = 0
              for i in range(k):
                if app[i] != 0:
                  vect[0] = app[i]
                  break
              for i in range(k - 1, -1, -1):
                if app[i] != 0:
                  vect[1] = app[i]
                  break
            else:
              vect[0] = 255
              vect[1] = 0

          #  TODO: this function takes 90% of execution time, improve it
          #  Computation of the vertices (Y0,CrMax) and (Y1,CrMax) of the trapezium in the YCr subspace
          #  Computation of the vertices (Y2,CbMin) and (Y3,CbMin) of the trapezium in the YCb subspace
          def calculateValueMinMaxY(image, val: float, hist, canal: int) -> list:
            minMax = [0] * 2
            min = 255
            max = 0
            indMax = 0
            indMin = 0
            tmpVal = val
            if canal == 1:
              tol = tolCr
            else:
              tol = tolCb
            indTol = (2 * (tol + 1)) - 1
            app = [0] * bins
            iBins = [0] * bins
            app2 = [0] * bins
            iBins2 = [0] * bins
            for i in range(bins):
              app[i] = 0
              app2[i] = 0
              iBins2[i] = 0
              iBins[i] = 0
            yValue = [0] * indTol
            iBinsVal = [0] * indTol
            for i in range(indTol):
              yValue[i] = [0] * bins
              iBinsVal[i] = [0] * bins
            for j in range(indTol):
              for i in range(bins):
                yValue[j][i] = 0
                iBinsVal[j][i] = 0
            
            height, width, channels = image.shape
            for i in range(height - 1):
              for j in range(width - 1):
                spk = image[i, j, canal]
                if spk >= tmpVal - tol and spk <= tmpVal + tol:
                  k = image[i, j, 0]
                  bin_val = 0
                  bin_val = hist[k, spk]
                  if bin_val != 0:
                    for l in range(indTol):
                      if int(tmpVal - spk + l) == tol:
                        yValue[l][k] = bin_val
                        iBinsVal[l][k] = k

            for i in range(indTol):
              for k in range(bins):
                app[k] = yValue[i][k]
                iBins[k] = iBinsVal[i][k]
              app = sortHist(app, iBins, k - 1)

              j = 1
              for k in range(bins):
                if app[k] != 0:
                  app2[j] = app[k]
                  iBins2[j] = iBins[k]
                  j = j+1
              app2[0] = j
              minMax[0] = 255
              minMax[1] = 0

              #  Computation of Min and Max of the histogram
              calcMinMaxHist(app2, iBins2, minMax)
              if minMax[0] != minMax[1]:
                if minMax[0] != 255:
                  indMin = indMin+1
                  if minMax[0] < min:
                    min = minMax[0]
                if minMax[1] != 0:
                  indMax = indMax+1
                  if minMax[1] > max:
                    max = minMax[1]
            minMax[0] = min
            minMax[1] = max
            return minMax

          def calculateHist(plane1):
            return cv2.calcHist([plane1],[0],None,[256],[0,256])

          def calculateHist2(plane1, plane2):
            img = np.dstack((plane1,plane2))
            return cv2.calcHist([img], [0, 1], None, [256, 256], [0, 256, 0, 256])


          #  TODO: improve precision with more consistent data types
          def skin_detect(image_in: str, image_out: str):
            '''
            Detect skin pixels in image_in and save the result into a 
            file named like image_out   
            '''
            CrMin = float(133)
            CrMax = float(183)
            CbMin = float(77)
            CbMax = float(128)

            try:
              source = cv2.imread(image_in, cv2.IMREAD_COLOR)
            except:
              exit('No input image found')
            
            height, width, channels = source.shape

            minMaxCr = [0] * 2
            minMaxCb = [0] * 2


            #  ALGORITHM
            frame_rgb = source.copy()
            perc = width * height * 0.1 / 100

            frame_ycrcb = cv2.cvtColor(frame_rgb, cv2.COLOR_BGR2YCR_CB)

            y_plane, cr_plane, cb_plane = cv2.split(frame_ycrcb)

            histCb = calculateHist(cb_plane)
            histCr = calculateHist(cr_plane)

            max_valCr = 0
            minMaxCr[0] = 255
            minMaxCr[1] = 0
            minMaxCb[0] = 255
            minMaxCb[1] = 0

            #  Computation of Crmax
            for i in range(bins - 1, -1, -1):
              if histCr[i] != 0 and histCr[i] > perc:
                max_valCr = i
                break

            #  Computation of Cbmin
            min_valCb = 0
            for i in range(bins):
              if histCb[i] != 0 and histCb[i] > perc:
                min_valCb = i
                break
            
            histYCb = calculateHist2(y_plane, cb_plane)
            histYCr = calculateHist2(y_plane, cr_plane)
            
            #  Computation of (Y0,CrMax) and (Y1,CrMax) by means of the calculus of percentiles
            if max_valCr != -1:
              if max_valCr > CrMax:
                max_valCr = CrMax
              minMaxCr = calculateValueMinMaxY(frame_ycrcb, max_valCr, histYCr, 1)
              if max_valCr < CrMax:
                CrMax = max_valCr

            #  Computation of (Y2,CbMin) and (Y3,CbMin) by means of the calculus of percentiles
            if min_valCb != -1:
              if min_valCb < CbMin:
                min_valCb = CbMin
              minMaxCb = calculateValueMinMaxY(frame_ycrcb, min_valCb, histYCb, 2)
              if min_valCb > CbMin:
                CbMin = min_valCb

            Y0 = 50
            Y1 = 110
            Y2 = 140
            Y3 = 200
            #  Store of Y0, Y1
            if max_valCr != -1:
              Y0 = minMaxCr[0]
              Y1 = minMaxCr[1]
            #  Store of Y2, Y3
            if min_valCb != -1:
              Y2 = minMaxCb[0]
              Y3 = minMaxCb[1]
            
            bw_final = np.zeros((height, width, 1), np.uint8)
            ACr = 0
            ACb = 0
            B = 256
            bCr = Y1 - Y0
            bCb = Y3 - Y2
            if bCr > bCb:
              maxb = bCr
              minb = bCb
            else:
              maxb = bCb
              minb = bCr
            hCr = float(CrMax - CrMin)
            hCb = float(CbMax - CbMin)
            ACr = ((B + bCr) * hCr) / 2
            ACb = ((B + bCb) * hCb) / 2

            Y = y_plane
            Cr = cr_plane
            Cb = cb_plane

            #  Calculate HCr
            #  With loops it had 3 if conditions: translate them into masks and matrix multiplications.
            #  Each mask represent a condition and its truth values are multiplied by the
            #  values that would have been inside the condition
            HCr = np.zeros_like(Y)
            # numpy.putmask(matrix, mask, new_matrix_values)
            np.putmask(HCr, (Y >= 0) & (Y < Y0), (CrMin + hCr * (np.float64(Y) / Y0)).astype(np.uint8))
            np.putmask(HCr, (Y >= Y0) & (Y < Y1), CrMax)
            np.putmask(HCr, (Y >= Y1) & (Y<= 255), (CrMin + hCr * ((np.float64(Y) - 255) / (Y1 - 255))).astype(np.uint8))

            #  TODO: use cleaner approach to perform color subtraction / saturated subtraction
            #  Calculate HCb
            #  arr[arr - subtract_me < threshold] = threshold
            HCb = np.zeros_like(Y)
            np.putmask(HCb, (Y >= 0) & (Y < Y2), (CbMin + hCb * ((np.int8(Y) - Y2) / (0 - Y2))).astype(np.uint8))
            np.putmask(HCb, (Y >= Y2) & (Y < Y3), CbMin)
            np.putmask(HCb, (Y >= Y3) & (Y <= 255), (CbMin + hCb * ((np.float64(Y) - Y3) / (255 - Y3))).astype(np.uint8))

            dCr = Cr - CrMin
            DCr = HCr - CrMin
            DCb = CbMax - HCb

            if ACr > ACb:
              D1Cr = DCr * ACb / ACr
              D1Cb = DCb
            else:
              D1Cr = DCr
              D1Cb = DCb * ACr / ACb
            alpha = np.true_divide(D1Cb, D1Cr)
            dCbS = np.zeros_like(alpha)
            np.putmask(dCbS, D1Cr > 0, np.multiply(dCr, alpha))
            np.putmask(dCbS, D1Cr <= 0, 255)

            CbS = CbMax - dCbS

            sf = float(minb) / float(maxb)

            #  Condition C.0
            Ivals = (D1Cr + D1Cb) - (dCr + dCbS)
            I = np.absolute(Ivals) * sf

            #  Condition C.1
            Jvals = np.multiply(dCbS, np.true_divide((dCbS + dCr), (D1Cb + D1Cr)))
            J = np.zeros_like(alpha)
            np.putmask(J, (D1Cb + D1Cr) > 0, Jvals)
            np.putmask(J, (D1Cb + D1Cr) <= 0, 255)

            #  Skin pixels
            mask1 = cv2.subtract(Cr, Cb) >= I
            mask2 = np.absolute(np.float64(Cb) - CbS).astype(np.uint8) <= J
            np.putmask(bw_final, mask1 & mask2, 255)
            
            #cv2.imwrite(image_out, bw_final)
            return bw_final, source
          

          # Download the given image to virtual file system
          tries = 0
          while True: # keep trying till getting a valid image
            if tries > 0:
              info(f'Try #{tries+1}')
            elif tries > 6:
              info(f'Cannot fetch any image!')
              break
            try:
              response = await pyfetch(img_url, redirect = 'follow')
              if response.status == 200:
                filename = os.path.basename(response.url)
                with open(filename, "wb") as f:
                  f.write(await response.bytes())
                info('Image successfully written to virtual file system')
                break
            except:
              info('Error on the given image, trying on a random image instead')
              img_url = random.choice(samples)
              tries = tries +1
          
          # Run skin detector
          try:
            outcome, origin = skin_detect(filename, 'img.png')
            info('Skin detector ran without issues')
          except:
            info('Error while detecting skin, please try again with a different image')

          info('Encoding image')
          
          # Return image as base64 encoded string
          img_data = base64.b64encode(cv2.imencode('.png', outcome)[1]).decode()

          if tries > 0:
            info('Finish with sample image (invalid url)')
          else:
            info('Finish')

          # Return original image
          ori_data = base64.b64encode(cv2.imencode('.png', origin)[1]).decode()

          image_height, image_width, image_channels = outcome.shape

          # Update widths
          js.document.getElementById("imgbox").style.width = f'{image_width}px'
          js.document.getElementById("imgbox-ori").style.width = f'{image_width}px'
          js.document.getElementById("slider").style.width = f'{image_width+50}px'
          # Update heights
          js.document.getElementById("imgbox").style.height = f'{image_height}px'
          js.document.getElementById("imgbox-ori").style.height = f'{image_height}px'
          js.document.getElementById("slider").style.height = f'{image_height}px'
          js.document.getElementById("slider-container").style.height = f'{image_height+50}px'
      `);

      img_data = pyodide.globals.get("img_data");
      ori_data = pyodide.globals.get("ori_data");

      document.getElementById("imgbox").src = "data:image/png;base64," + img_data;
      document.getElementById("imgbox-ori").src = "data:image/png;base64," + ori_data;
      console.log("Image replaced with predicted data");

      // init comparison slider transparency
      let slideValue = document.getElementById("slider").value;
      document.getElementById("imgbox").style.clipPath = "polygon(0 0," + slideValue + "% 0," + slideValue + "% 100%, 0 100%)";

      document.getElementById("slider-container").style.visibility = "visible";
    }
  </script>

<!-- End Document
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
</body>
</html>